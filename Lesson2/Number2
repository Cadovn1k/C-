package Site2ndweek;

import java.io.*;
import java.util.Arrays;

public class Nn2 {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader("input.txt"))) {
            String line = br.readLine(); // считаем сначала первую строку
            final LineNumberReader lnr = new LineNumberReader(new FileReader(new File("input.txt")));
            int r=0;
            String l1="";
            String l2="";
            while(null != lnr.readLine()) {
                if(r==0){
                    l1=line;
                    r=1;
                    line = br.readLine();
                }
                else
                    l2=line;
            }
            String[] customer = l2.split(" ");//разделены пробелом
            long mas[]= new long [Integer.parseInt(l1)];
            for (long i=0; i<mas.length; i++){
                mas[(int)i]= Long.parseLong(customer[(int)i]);
            }

            long s=mergeSort(mas,mas.length); //усовршенствованный метод сортировки слиянием для подсчета инверсий


            System.out.println(Arrays.toString(mas));
            System.out.println(s);
            FileWriter writer = new FileWriter("output.txt"); //загрузка в файл
            writer.write(String.valueOf(s));
            writer.close();

        }
        catch(IOException ex){
            System.out.println(ex.getMessage());
        }
    }

    static long mergeSort(long arr[], long array_size) {   // Этот метод сортирует входной массив и возвращает количество инверсий в массиве
        long temp[] = new long [(int) array_size];
        return _mergeSort(arr, temp, 0, (int) (array_size - 1));
    }

    static long _mergeSort(long arr[], long temp[], int left, int right){  //Вспомогательный рекурсивный метод, который сортирует входной массив и возвращает количество инверсий в массиве.

        int mid;
        long inv_count = 0;

        if (right > left) {   // Разделите массив на две части и вызовите _mergeSortAndCountInv () для каждой из частей
            mid = (right + left) / 2;  // Счетчик инверсий будет суммой инверсий в левой части, правой части и количество инверсий в слиянии

            inv_count = _mergeSort(arr, temp, left, mid);

            inv_count += _mergeSort(arr, temp, mid + 1, right); // Объединить две части

            inv_count += merge(arr, temp, left, mid + 1, right);

        }

        return inv_count;
    }

    static long merge(long arr[], long temp[], int left, int mid, int right) { //Этот метод объединяет два отсортированных массива и возвращает количество инверсий в массиве.
        int i, j, k;
        long inv_count = 0;
        i = left; // я индекс для левого подмассива

        j = mid; // j - индекс для правого подмассива

        k = left; // k - индекс для результирующего объединенного подмассива

        while ((i <= mid - 1) && (j <= right)) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            }
            else {
                temp[k++] = arr[j++];  // это сложно - см. выше объяснение / диаграмма для слияния ()
                inv_count = inv_count + (mid - i);
            }
        }

        while (i <= mid - 1) { // Копировать оставшиеся элементы левого подмассива (если таковые имеются), чтобы временно
            temp[k++] = arr[i++];
        }

        // Копировать остальные элементы правого подмассива (если таковые имеются), чтобы временно
        while (j <= right) {
            temp[k++] = arr[j++];
        }

        // Скопировать обратно объединенные элементы в исходный массив
        for (i = left; i <= right; i++) {
            arr[i] = temp[i];
        }
        return inv_count;

    }

}

